package nl.degrijs.servicelocator;

import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

import static nl.degrijs.servicelocator.ValidateServiceParameters.notEmpty;
import static nl.degrijs.servicelocator.ValidateServiceParameters.notNull;

/**
 * A very simple implementation of service locator pattern followinng the KISS principle
 * <p>
 * This version has only two types of instances: singleton and a prototype. The prototype is
 * generated by means of a supplier.
 * </p>
 * <p>
 * Since the object cache is used throughout the application a ConcurrentHashmap is used
 * to make it threadsafe.
 * </p>
 */
public class ServiceLocator {
    private static final ServiceLocator                           SERVICE_LOCATOR = new ServiceLocator();
    private final        ConcurrentHashMap<ServiceKey<?>, Object> serviceCache;

    static {
        // prevent memory leak
        Runtime.getRuntime()
                .addShutdownHook(new Thread(() -> SERVICE_LOCATOR.clear()));
    }

    public ServiceLocator() {
        serviceCache = new ConcurrentHashMap<>();
    }

    public <T> ServiceLocator registerSingleton(Class<T> clz, T instance) {
        notNull(clz, "Class is missing");
        notNull(instance, "Instance is missing");

        serviceCache.put(ServiceKey.createServiceKey(clz), instance);
        return this;
    }

    public <T> ServiceLocator registerSingleton(Class<T> clz, String discriminator, T instance) {
        notNull(clz, "Class is missing");
        notEmpty(discriminator, "Discriminator has no value");
        notNull(instance, "Instance is missing");

        serviceCache.put(ServiceKey.createServiceKey(clz, discriminator), instance);
        return this;
    }


    public <T> ServiceLocator registerPrototype(Class<T> clz, Supplier<T> instance) {
        notNull(clz, "Class is missing");
        notNull(instance, "Supplier is missing");

        serviceCache.put(ServiceKey.createServiceKey(clz), instance);
        return this;
    }

    public <T> ServiceLocator registerPrototype(Class<T> clz, String discriminator, Supplier<T> instance) {
        notNull(clz, "Class is missing");
        notEmpty(discriminator, "Discriminator has no value");
        notNull(instance, "Supplier is missing");

        serviceCache.put(ServiceKey.createServiceKey(clz, discriminator), instance);
        return this;
    }

    /**
     * Removes entry of nothing if nothing found
     *
     * @param clz
     * @param <T>
     * @return
     */
    public <T> ServiceLocator removeSingleton(Class<T> clz) {
        notNull(clz, "Class is missing");

        removeEntry(ServiceKey.createServiceKey(clz));
        return this;
    }

    /**
     * Removes entry of nothing if nothing found
     *
     * @param clz
     * @param discriminator
     * @param <T>
     * @return
     */
    public <T> ServiceLocator removeSingleton(Class<T> clz, String discriminator) {
        notNull(clz, "Class is missing");
        notEmpty(discriminator, "Discriminator has no value");
        removeEntry(ServiceKey.createServiceKey(clz, discriminator));
        return this;
    }

    /**
     * Removes entry of nothing if nothing found
     *
     * @param clz
     * @param <T>
     * @return
     */
    public <T> ServiceLocator removeSupplier(Class<T> clz) {
        notNull(clz, "Class is missing");
        isSupplier(clz);

        removeEntry(ServiceKey.createServiceKey(clz));
        return this;
    }


    /**
     * Removes entry of nothing if nothing found
     *
     * @param clz
     * @param discriminator
     * @param <T>
     * @return
     */
    public <T> ServiceLocator removeSupplier(Class<T> clz, String discriminator) {
        notNull(clz, "Class is missing");
        isSupplier(clz);
        notEmpty(discriminator, "Discriminator has no value");

        removeEntry(ServiceKey.createServiceKey(clz, discriminator));
        return this;
    }


    public void clear() {
        ServiceKey.clearCache();
        serviceCache.clear();
    }

    public <T> Optional<T> getSingleton(Class<T> clz) {
        notNull(clz, "Class is missing");
        return (Optional<T>) Optional.ofNullable(serviceCache.get(ServiceKey.createServiceKey(clz)));
    }

    public <T> Optional<T> getSingleton(Class<T> clz, String discriminator) {
        notNull(clz, "Class is missing");
        notEmpty(discriminator, "Discriminator has no value");
        return (Optional<T>) Optional.ofNullable(serviceCache.get(ServiceKey.createServiceKey(clz, discriminator)));
    }

    public <T> Optional<T> getPrototype(Class<T> clz) {
        notNull(clz, "Class is missing");
        isSupplier(clz);

        Supplier<T> supplier = (Supplier<T>) serviceCache.get(ServiceKey.createServiceKey(clz));
        return (Optional<T>) Optional.ofNullable(supplier == null ? null : supplier.get());
    }

    public <T> Optional<T> getPrototype(Class<T> clz, String discriminator) {
        notNull(clz, "Class is missing");
        isSupplier(clz);
        notEmpty(discriminator, "Discriminator has no value");

        Supplier<T> supplier = (Supplier<T>) serviceCache.get(ServiceKey.createServiceKey(clz, discriminator));
        return (Optional<T>) Optional.ofNullable(supplier == null ? null : supplier.get());
    }


    public static ServiceLocator getInstance() {
        return SERVICE_LOCATOR;
    }

    private void removeEntry(ServiceKey serviceKey) {
        if (serviceCache.containsKey(serviceKey)) {
            serviceCache.remove(serviceKey);
            ServiceKey.remove(serviceKey);
        }
    }

    private <T> void isSupplier(Class<T> clz) {
        if (serviceCache.containsKey(clz)) {
            if (!(serviceCache.get(clz) instanceof Supplier)) {
                throw new IllegalArgumentException("There is no supplier for class " + clz.getName());
            }
        }
    }

}
